/-
Copyright (c) 2025 ModularPhysics Contributors. All rights reserved.
Released under Apache 2.0 license.
Authors: ModularPhysics Contributors
-/
import Mathlib.Analysis.VonNeumannAlgebra.Basic
import Mathlib.Analysis.InnerProductSpace.Adjoint
import Mathlib.Analysis.InnerProductSpace.Projection.Basic
import Mathlib.Topology.Algebra.Module.WeakDual

/-!
# Von Neumann Algebras - Basic Theory

This file develops the basic theory of von Neumann algebras, building on Mathlib's
`VonNeumannAlgebra` and `WStarAlgebra` definitions.

We introduce:
- Cyclic vectors: vectors Î© such that MÂ·Î© is dense in H
- Separating vectors: vectors Î© such that aÎ© = 0 implies a = 0
- Cyclic-separating vectors for standard form

## Main definitions

* `VonNeumannAlgebra.IsCyclic` - predicate for cyclic vectors
* `VonNeumannAlgebra.IsSeparating` - predicate for separating vectors
* `VonNeumannAlgebra.IsCyclicSeparating` - predicate for cyclic and separating vectors
* `VonNeumannAlgebra.cyclicSubspace` - the closure of MÂ·Î©

## Main results

* `VonNeumannAlgebra.separating_iff_cyclic_commutant` - Î© separating for M iff cyclic for M'

## References

* Takesaki, "Theory of Operator Algebras I"
* Bratteli-Robinson, "Operator Algebras and Quantum Statistical Mechanics"
-/

noncomputable section

open scoped InnerProduct ComplexConjugate

universe u

variable {H : Type u} [NormedAddCommGroup H] [InnerProductSpace â„‚ H] [CompleteSpace H]

namespace VonNeumannAlgebra

variable (M : VonNeumannAlgebra H)

/-! ### Cyclic vectors -/

/-- The orbit of a vector under a von Neumann algebra -/
def orbit (Î© : H) : Set H :=
  { x : H | âˆƒ a âˆˆ M, a Î© = x }

/-- The cyclic subspace generated by Î© under M, i.e., the closure of MÂ·Î© -/
def cyclicSubspace (Î© : H) : Submodule â„‚ H :=
  Submodule.topologicalClosure (Submodule.span â„‚ (M.orbit Î©))

/-- A vector Î© is cyclic for M if MÂ·Î© is dense in H -/
def IsCyclic (Î© : H) : Prop :=
  M.cyclicSubspace Î© = âŠ¤

/-- A vector Î© is separating for M if aÎ© = 0 implies a = 0 for all a âˆˆ M -/
def IsSeparating (Î© : H) : Prop :=
  âˆ€ a âˆˆ M, (a : H â†’L[â„‚] H) Î© = 0 â†’ a = 0

/-- A vector is cyclic-separating if it is both cyclic and separating -/
def IsCyclicSeparating (Î© : H) : Prop :=
  M.IsCyclic Î© âˆ§ M.IsSeparating Î©

/-! ### Basic properties of cyclic vectors -/

theorem orbit_nonempty (Î© : H) : (M.orbit Î©).Nonempty := by
  use Î©
  exact âŸ¨1, M.toStarSubalgebra.one_mem, ContinuousLinearMap.one_apply Î©âŸ©

theorem zero_mem_orbit_of_zero : (0 : H) âˆˆ M.orbit (0 : H) := by
  exact âŸ¨0, M.toStarSubalgebra.zero_mem, map_zero 0âŸ©

theorem Î©_mem_orbit (Î© : H) : Î© âˆˆ M.orbit Î© := by
  exact âŸ¨1, M.toStarSubalgebra.one_mem, ContinuousLinearMap.one_apply Î©âŸ©

theorem orbit_subset_cyclicSubspace (Î© : H) : M.orbit Î© âŠ† M.cyclicSubspace Î© := fun _ hx =>
  (Submodule.span â„‚ (M.orbit Î©)).le_topologicalClosure (Submodule.subset_span hx)

theorem Î©_mem_cyclicSubspace (Î© : H) : Î© âˆˆ M.cyclicSubspace Î© :=
  M.orbit_subset_cyclicSubspace Î© (M.Î©_mem_orbit Î©)

/-- The orbit is closed under the algebra action -/
theorem orbit_closed_under_action (Î© : H) (a b : H â†’L[â„‚] H) (ha : a âˆˆ M) (hb : b âˆˆ M)
    (_ : b Î© âˆˆ M.orbit Î©) : (a âˆ˜L b) Î© âˆˆ M.orbit Î© := by
  exact âŸ¨a âˆ˜L b, M.toStarSubalgebra.mul_mem ha hb, rflâŸ©

/-- The cyclic subspace is M-invariant -/
theorem cyclicSubspace_invariant (Î© : H) (a : H â†’L[â„‚] H) (ha : a âˆˆ M) :
    âˆ€ x âˆˆ M.cyclicSubspace Î©, a x âˆˆ M.cyclicSubspace Î© := by
  intro x hx
  unfold cyclicSubspace at hx âŠ¢
  -- x is in the topological closure of span(MÂ·Î©)
  -- Key: a maps orbit(Î©) into itself (actually into span)
  have h_orbit : âˆ€ y âˆˆ M.orbit Î©, a y âˆˆ Submodule.span â„‚ (M.orbit Î©) := by
    intro y hy
    obtain âŸ¨b, hb, rflâŸ© := hy
    apply Submodule.subset_span
    exact âŸ¨a âˆ˜L b, M.toStarSubalgebra.mul_mem ha hb, rflâŸ©
  -- a maps span(MÂ·Î©) into itself by linearity
  have h_span : âˆ€ y âˆˆ Submodule.span â„‚ (M.orbit Î©), a y âˆˆ Submodule.span â„‚ (M.orbit Î©) := by
    intro y hy
    have hmem : âˆ€ z âˆˆ M.orbit Î©, a z âˆˆ Submodule.span â„‚ (M.orbit Î©) := h_orbit
    have hzero : a 0 âˆˆ Submodule.span â„‚ (M.orbit Î©) := by simp
    have hadd : âˆ€ u v, a u âˆˆ Submodule.span â„‚ (M.orbit Î©) â†’ a v âˆˆ Submodule.span â„‚ (M.orbit Î©) â†’
                a (u + v) âˆˆ Submodule.span â„‚ (M.orbit Î©) := by
      intro u v hu hv; simp only [map_add]; exact Submodule.add_mem _ hu hv
    have hsmul : âˆ€ (c : â„‚) u, a u âˆˆ Submodule.span â„‚ (M.orbit Î©) â†’
                 a (c â€¢ u) âˆˆ Submodule.span â„‚ (M.orbit Î©) := by
      intro c u hu; simp only [ContinuousLinearMap.map_smul]; exact Submodule.smul_mem _ c hu
    -- Use span induction
    refine Submodule.span_induction ?_ ?_ ?_ ?_ hy
    Â· exact hmem
    Â· exact hzero
    Â· intro u v _ _ hu hv; exact hadd u v hu hv
    Â· intro c u _ hu; exact hsmul c u hu
  -- Use continuity: a maps closure into closure
  -- Since a(S) âŠ† S for S = span(MÂ·Î©), we have a(closure(S)) âŠ† closure(a(S)) âŠ† closure(S)
  let S := Submodule.span â„‚ (M.orbit Î©)
  -- Step 1: a '' closure(S) âŠ† closure(a '' S) by continuity
  have step1 : a '' closure (S : Set H) âŠ† closure (a '' (S : Set H)) :=
    image_closure_subset_closure_image a.continuous
  -- Step 2: a '' S âŠ† S, so closure(a '' S) âŠ† closure(S)
  have h_image_sub : a '' (S : Set H) âŠ† (S : Set H) := by
    intro z hz
    obtain âŸ¨y, hy, rflâŸ© := hz
    exact h_span y hy
  have step2 : closure (a '' (S : Set H)) âŠ† closure (S : Set H) :=
    closure_mono h_image_sub
  -- Combine: a '' closure(S) âŠ† closure(S)
  have combined : a '' closure (S : Set H) âŠ† closure (S : Set H) := step1.trans step2
  -- x âˆˆ closure(S), so a x âˆˆ a '' closure(S) âŠ† closure(S)
  -- topologicalClosure_coe is definitional: â†‘S.topologicalClosure = closure â†‘S
  -- So S.topologicalClosure membership is the same as closure â†‘S membership
  simp only [â† SetLike.mem_coe, Submodule.topologicalClosure_coe] at hx âŠ¢
  exact combined âŸ¨x, hx, rflâŸ©

/-! ### Relationship between cyclic and separating -/

/-- Key theorem: Î© is separating for M if and only if Î© is cyclic for M' (the commutant).
    This is a fundamental result in Tomita-Takesaki theory. -/
theorem separating_iff_cyclic_commutant (Î© : H) :
    M.IsSeparating Î© â†” M.commutant.IsCyclic Î© := by
  constructor
  Â· -- If Î© is separating for M, it is cyclic for M'
    intro hsep
    -- The key insight: if x âŠ¥ M'Â·Î©, then for all b âˆˆ M', âŸ¨x, bÎ©âŸ© = 0
    -- Define a_x âˆˆ M'' = M by âŸ¨a_x Î©, Î¾âŸ© = âŸ¨x, Î¾âŸ© for Î¾ âˆˆ M'Â·Î©
    -- Then a_x Î© = x, but also a_x = 0 by density argument, so x = 0
    unfold IsCyclic cyclicSubspace
    sorry
  Â· -- If Î© is cyclic for M', it is separating for M
    intro hcyc a ha haÎ©
    -- If aÎ© = 0, then for all b âˆˆ M', âŸ¨aÎ©, bÎ©âŸ© = 0
    -- But âŸ¨aÎ©, bÎ©âŸ© = âŸ¨Î©, aâ€ bÎ©âŸ© = âŸ¨Î©, baâ€ Î©âŸ© (since a âˆˆ M, b âˆˆ M' commute)
    -- Since M'Â·Î© is dense, aâ€ Î© = 0, and by similar argument a = 0
    sorry

/-- Cyclic for M implies separating for M' -/
theorem cyclic_implies_separating_commutant (Î© : H) (h : M.IsCyclic Î©) :
    M.commutant.IsSeparating Î© := by
  rw [separating_iff_cyclic_commutant]
  simp only [commutant_commutant]
  exact h

/-- Separating for M implies cyclic for M' -/
theorem separating_implies_cyclic_commutant (Î© : H) (h : M.IsSeparating Î©) :
    M.commutant.IsCyclic Î© :=
  (separating_iff_cyclic_commutant M Î©).mp h

/-! ### Standard form -/

/-- A von Neumann algebra is in standard form if there exists a cyclic-separating vector -/
def IsStandardForm : Prop :=
  âˆƒ Î© : H, M.IsCyclicSeparating Î©

/-- For standard form, the commutant also has the same cyclic-separating vector -/
theorem standard_form_commutant (Î© : H) (h : M.IsCyclicSeparating Î©) :
    M.commutant.IsCyclicSeparating Î© := by
  constructor
  Â· exact M.separating_implies_cyclic_commutant Î© h.2
  Â· exact M.cyclic_implies_separating_commutant Î© h.1

/-- The standard form is symmetric: if (M, H, Î©) is standard, so is (M', H, Î©) -/
theorem standard_form_symmetric (Î© : H) (h : M.IsCyclicSeparating Î©) :
    M.commutant.IsCyclicSeparating Î© :=
  M.standard_form_commutant Î© h

end VonNeumannAlgebra

/-! ### Faithful states and cyclic representations -/

namespace VonNeumannAlgebra

variable (M : VonNeumannAlgebra H)

/-- A state on M given by a unit vector -/
structure VectorState (M : VonNeumannAlgebra H) where
  vec : H
  norm_one : â€–vecâ€– = 1

/-- The state functional Ï‰(a) = âŸ¨Î©, aÎ©âŸ© -/
def VectorState.functional (Ï‰ : VectorState M) (a : H â†’L[â„‚] H) (_ : a âˆˆ M) : â„‚ :=
  @inner â„‚ H _ Ï‰.vec (a Ï‰.vec)

/-- A vector state is positive: Ï‰(a*a) â‰¥ 0 -/
theorem VectorState.positive (Ï‰ : VectorState M) (a : H â†’L[â„‚] H) (_ha : a âˆˆ M) :
    0 â‰¤ (@inner â„‚ H _ Ï‰.vec ((ContinuousLinearMap.adjoint a âˆ˜L a) Ï‰.vec)).re := by
  simp only [ContinuousLinearMap.coe_comp', Function.comp_apply]
  have h : @inner â„‚ H _ Ï‰.vec ((ContinuousLinearMap.adjoint a) (a Ï‰.vec)) =
           @inner â„‚ H _ (a Ï‰.vec) (a Ï‰.vec) := by
    exact ContinuousLinearMap.adjoint_inner_right a Ï‰.vec (a Ï‰.vec)
  rw [h]
  exact inner_self_nonneg (ğ•œ := â„‚) (x := a Ï‰.vec)

/-- A vector state is faithful if Ï‰(a*a) = 0 implies a = 0 -/
def VectorState.IsFaithful (Ï‰ : VectorState M) : Prop :=
  âˆ€ a âˆˆ M, @inner â„‚ H _ Ï‰.vec ((ContinuousLinearMap.adjoint a âˆ˜L a) Ï‰.vec) = 0 â†’ a = 0

/-- A faithful vector state has a separating vector -/
theorem VectorState.faithful_implies_separating (Ï‰ : VectorState M) (hf : Ï‰.IsFaithful) :
    M.IsSeparating Ï‰.vec := by
  intro a ha haÎ©
  apply hf a ha
  simp only [ContinuousLinearMap.coe_comp', Function.comp_apply, haÎ©, map_zero, inner_zero_right]

/-- A separating vector gives a faithful state -/
theorem separating_implies_faithful (Î© : H) (hÎ© : â€–Î©â€– = 1) (hsep : M.IsSeparating Î©) :
    (âŸ¨Î©, hÎ©âŸ© : VectorState M).IsFaithful := by
  intro a ha hinner
  simp only [ContinuousLinearMap.coe_comp', Function.comp_apply] at hinner
  have h : @inner â„‚ H _ Î© ((ContinuousLinearMap.adjoint a) (a Î©)) =
           @inner â„‚ H _ (a Î©) (a Î©) := ContinuousLinearMap.adjoint_inner_right a Î© (a Î©)
  rw [h] at hinner
  have haÎ© : a Î© = 0 := by
    rw [â† inner_self_eq_zero (ğ•œ := â„‚)]
    exact hinner
  exact hsep a ha haÎ©

end VonNeumannAlgebra

/-! ### Projections in von Neumann algebras -/

namespace VonNeumannAlgebra

variable (M : VonNeumannAlgebra H)

/-- A projection in M is a self-adjoint idempotent element -/
structure Projection (M : VonNeumannAlgebra H) where
  op : H â†’L[â„‚] H
  mem : op âˆˆ M
  idem : op âˆ˜L op = op
  selfadj : ContinuousLinearMap.adjoint op = op

/-- The zero projection -/
def Projection.zero : Projection M where
  op := 0
  mem := M.toStarSubalgebra.zero_mem
  idem := by ext x; simp only [ContinuousLinearMap.coe_comp', Function.comp_apply,
    ContinuousLinearMap.zero_apply]
  selfadj := by simp only [map_zero]

/-- The identity projection -/
def Projection.one : Projection M where
  op := 1
  mem := M.toStarSubalgebra.one_mem
  idem := by ext x; simp only [ContinuousLinearMap.coe_comp', Function.comp_apply,
    ContinuousLinearMap.one_apply]
  selfadj := ContinuousLinearMap.adjoint_id

/-- Projections are positive operators -/
theorem Projection.positive (p : Projection M) (x : H) :
    0 â‰¤ (@inner â„‚ H _ x (p.op x)).re := by
  have key : @inner â„‚ H _ x (p.op x) = @inner â„‚ H _ (p.op x) (p.op x) := by
    -- Step 1: p(px) = px since pÂ² = p
    have idem_app : p.op (p.op x) = p.op x := by
      have := congrFun (congrArg DFunLike.coe p.idem) x
      simp only [ContinuousLinearMap.coe_comp', Function.comp_apply] at this
      exact this
    -- Step 2: Use p = pâ€  then adjoint_inner_right
    -- âŸ¨x, p(px)âŸ© = âŸ¨x, pâ€ (px)âŸ© = âŸ¨px, pxâŸ©
    have step2 : @inner â„‚ H _ x (p.op (p.op x)) =
                 @inner â„‚ H _ x ((ContinuousLinearMap.adjoint p.op) (p.op x)) := by
      congr 2
      exact p.selfadj.symm
    calc @inner â„‚ H _ x (p.op x)
        = @inner â„‚ H _ x (p.op (p.op x)) := by rw [idem_app]
      _ = @inner â„‚ H _ x ((ContinuousLinearMap.adjoint p.op) (p.op x)) := step2
      _ = @inner â„‚ H _ (p.op x) (p.op x) := ContinuousLinearMap.adjoint_inner_right p.op x (p.op x)
  rw [key]
  exact inner_self_nonneg (ğ•œ := â„‚)

/-- The range of a projection is a closed subspace -/
def Projection.rangeSubmodule (p : Projection M) : Submodule â„‚ H :=
  LinearMap.range p.op.toLinearMap

/-- The kernel of a projection is a closed subspace -/
def Projection.kerSubmodule (p : Projection M) : Submodule â„‚ H :=
  LinearMap.ker p.op.toLinearMap

/-- Support projection of a vector -/
def supportProjection (Î© : H) : Submodule â„‚ H :=
  Submodule.span â„‚ {Î©}

end VonNeumannAlgebra
